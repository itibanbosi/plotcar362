{"README.md":"\r\n> このページを開く [https://itibanbosi.github.io/plotcarv31/](https://itibanbosi.github.io/plotcarv31/)\r\n\r\n## 拡張機能として使用\r\n\r\nこのリポジトリは、MakeCode で **拡張機能** として追加できます。\r\n\r\n* [https://makecode.microbit.org/](https://makecode.microbit.org/) を開く\r\n* **新しいプロジェクト** をクリックしてください\r\n* ギアボタンメニューの中にある **拡張機能** をクリックしてください\r\n* **https://github.com/itibanbosi/plotcarv31** を検索してインポートします。\r\n\r\n## このプロジェクトを編集します ![ビルド ステータス バッジ](https://github.com/itibanbosi/plotcarv31/workflows/MakeCode/badge.svg)\r\n\r\nMakeCode でこのリポジトリを編集します。\r\n\r\n* [https://makecode.microbit.org/](https://makecode.microbit.org/) を開く\r\n* **読み込む** をクリックし、 **URLから読み込む...** をクリックしてください\r\n* **https://github.com/itibanbosi/plotcarv31** を貼り付けてインポートをクリックしてください\r\n\r\n## ブロックのプレビュー\r\n\r\nこの画像はマスター内の最後のコミットからのブロックコードを示しています。\r\nこのイメージは更新に数分かかる場合があります。\r\n\r\n![生成されたブロック](https://github.com/itibanbosi/plotcarv31/raw/master/.github/makecode/blocks.png)\r\n\r\n#### メタデータ (検索、レンダリングに使用)\r\n\r\n* for PXT/microbit\r\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\r\n\r\n\r\n\r\n> このページを開く [https://itibanbosi.github.io/pxt-plotcarv35/](https://itibanbosi.github.io/pxt-plotcarv35/)\r\n\r\n## 拡張機能として使用\r\n\r\nこのリポジトリは、MakeCode で **拡張機能** として追加できます。\r\n\r\n* [https://makecode.microbit.org/](https://makecode.microbit.org/) を開く\r\n* **新しいプロジェクト** をクリックしてください\r\n* ギアボタンメニューの中にある **拡張機能** をクリックしてください\r\n* **https://github.com/itibanbosi/pxt-plotcarv35** を検索してインポートします。\r\n\r\n## このプロジェクトを編集します ![ビルド ステータス バッジ](https://github.com/itibanbosi/pxt-plotcarv35/workflows/MakeCode/badge.svg)\r\n\r\nMakeCode でこのリポジトリを編集します。\r\n\r\n* [https://makecode.microbit.org/](https://makecode.microbit.org/) を開く\r\n* **読み込む** をクリックし、 **URLから読み込む...** をクリックしてください\r\n* **https://github.com/itibanbosi/pxt-plotcarv35** を貼り付けてインポートをクリックしてください\r\n\r\n## ブロックのプレビュー\r\n\r\nこの画像はマスター内の最後のコミットからのブロックコードを示しています。\r\nこのイメージは更新に数分かかる場合があります。\r\n\r\n![生成されたブロック](https://github.com/itibanbosi/pxt-plotcarv35/raw/master/.github/makecode/blocks.png)\r\n\r\n#### メタデータ (検索、レンダリングに使用)\r\n\r\n* for PXT/microbit\r\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\r\n","_locales/ja/plotcarv36-strings.json":"{\n  \"eureka_plotter_car.auto_led_off|block\": \"ﾏｲｸﾛﾋﾞｯﾄLED |%Matrix_LED|\",\n  \"eureka_plotter_car.cycle|block\": \"円の作図　回転方向|%RorL|,直径|%D_Num|cm\",\n  \"eureka_plotter_car.houkou.diagonal_left|block\": \"左ななめ前\",\n  \"eureka_plotter_car.houkou.diagonal_right|block\": \"右ななめ前\",\n  \"eureka_plotter_car.houkou.left_angle|block\": \"左へ直角\",\n  \"eureka_plotter_car.houkou.right_angle|block\": \"右へ直角\",\n  \"eureka_plotter_car.kyori.long|block\": \"長い\",\n  \"eureka_plotter_car.kyori.short|block\": \"短い\",\n  \"eureka_plotter_car.microbit2_decideLight|block\": \"ﾏｲｸﾛﾋﾞｯﾄの明るさｾﾝｻｰが|%limit|より暗い\",\n  \"eureka_plotter_car.microbit2_denkitemp|block\": \"ﾏｲｸﾛﾋﾞｯﾄの明るさｾﾝｻｰ値\",\n  \"eureka_plotter_car.microbit_LED.activate|block\": \"有効\",\n  \"eureka_plotter_car.microbit_LED.disable|block\": \"無効\",\n  \"eureka_plotter_car.microbit_version.Test_A|block\": \"Test_A\",\n  \"eureka_plotter_car.microbit_version.Test_B|block\": \"Test_B\",\n  \"eureka_plotter_car.microbit_version.V1_Turbo|block\": \"V1_ターボ\",\n  \"eureka_plotter_car.microbit_version.V2_Turbo|block\": \"V2_ターボ\",\n  \"eureka_plotter_car.microbit_version.Version1|block\": \"Version1\",\n  \"eureka_plotter_car.microbit_version.Version2|block\": \"Version2\",\n  \"eureka_plotter_car.microbit_version_info|block\": \"動作調整|%Version_info|\",\n  \"eureka_plotter_car.onoff.OFF|block\": \"OFF\",\n  \"eureka_plotter_car.onoff.ON|block\": \"ON\",\n  \"eureka_plotter_car.pen_updown.down|block\": \"下げる\",\n  \"eureka_plotter_car.pen_updown.up|block\": \"上げる\",\n  \"eureka_plotter_car.photo_LR_out|block\": \"左右とも|%wb|をふんでいる時　感度|%sikii| \",\n  \"eureka_plotter_car.photo_L_out|block\": \"左だけが|%wb|をふんでいる時　感度|%sikii| \",\n  \"eureka_plotter_car.photo_L|block\": \"左ﾌｫﾄﾘﾌﾚｸﾀｰ　|%limit_L|より小さい\",\n  \"eureka_plotter_car.photo_R_out|block\": \"右だけが|%wb|をふんでいる時　感度|%sikii| \",\n  \"eureka_plotter_car.photo_R|block\": \"右ﾌｫﾄﾘﾌﾚｸﾀｰ　|%limit_R|より小さい\",\n  \"eureka_plotter_car.phto_L|block\": \"左ﾌｫﾄﾘﾌﾚｸﾀｰ\",\n  \"eureka_plotter_car.phto_R|block\": \"右ﾌｫﾄﾘﾌﾚｸﾀｰ\",\n  \"eureka_plotter_car.plotter_Distance|block\": \"進行距離調整(1/1000) 少ない|%Dis|多い\",\n  \"eureka_plotter_car.plotter_RL.left|block\": \"左\",\n  \"eureka_plotter_car.plotter_RL.right|block\": \"右\",\n  \"eureka_plotter_car.plotter_degree|block\": \"回転量調整(1/1000) 少ない|%Deg|多い\",\n  \"eureka_plotter_car.plotter_houkou.backward|block\": \"後ろ\",\n  \"eureka_plotter_car.plotter_houkou.forward|block\": \"前\",\n  \"eureka_plotter_car.plottercar_L_step|block\": \"左車輪|%houkou|へ |%L_step|ステップ\",\n  \"eureka_plotter_car.plottercar_RL_cycle|block\": \"回転|%L_degree|度 |%RorL|まわり\",\n  \"eureka_plotter_car.plottercar_R_step|block\": \"右車輪|%houkou|へ |%R_step|ステップ\",\n  \"eureka_plotter_car.plottercar_frest|block\": \"電源OFF\",\n  \"eureka_plotter_car.plottercar_houkou|block\": \"|%muki|へ方向を変える\",\n  \"eureka_plotter_car.plottercar_pen2|block\": \"Newペン |%mode|(装置が底にあるﾀｲﾌﾟ) \",\n  \"eureka_plotter_car.plottercar_pen|block\": \"ペン|%mode| \",\n  \"eureka_plotter_car.plottercar_zengo|block\": \"|%zengo|へ |%F_cm|cm進む\",\n  \"eureka_plotter_car.polygon|block\": \"多角形の作図 回転方向|%RorL|,|%digree_step|角形,辺の長さ|%Edge_Num|cm\",\n  \"eureka_plotter_car.sence_select.High_sensitivity|block\": \"明るい部屋\",\n  \"eureka_plotter_car.sence_select.Low_sensitivity|block\": \"暗い部屋\",\n  \"eureka_plotter_car.sence_select.normal30|block\": \"普通の部屋\",\n  \"eureka_plotter_car.sonar_ping_2|block\": \"距離ｾﾝｻｰ\",\n  \"eureka_plotter_car.sonar_ping_3|block\": \"(最小 5cm) きょり|%limit|cmより|%nagasa| \",\n  \"eureka_plotter_car.whiteblack.black|block\": \"黒\",\n  \"eureka_plotter_car.whiteblack.white|block\": \"白\",\n  \"plotLED_blocks.driveForwards|block\": \"待ち時間(秒)|%second|\",\n  \"plotLED_blocks.neoLED_color.black|block\": \"黒\",\n  \"plotLED_blocks.neoLED_color.blue|block\": \"青\",\n  \"plotLED_blocks.neoLED_color.green|block\": \"緑\",\n  \"plotLED_blocks.neoLED_color.indigo|block\": \"こん色\",\n  \"plotLED_blocks.neoLED_color.orange|block\": \"だいだい\",\n  \"plotLED_blocks.neoLED_color.purple|block\": \"紫\",\n  \"plotLED_blocks.neoLED_color.red|block\": \"赤\",\n  \"plotLED_blocks.neoLED_color.violet|block\": \"すみれ\",\n  \"plotLED_blocks.neoLED_color.white|block\": \"白\",\n  \"plotLED_blocks.neoLED_color.yellow|block\": \"黄色\",\n  \"plotLED_blocks.neopixel_erace_block|block\": \"ﾌﾙｶﾗｰLEDを全部消す\",\n  \"plotLED_blocks.neopixel_rainbow|block\": \"にじ色\",\n  \"plotLED_blocks.neopixel_select_block|block\": \"ﾌﾙｶﾗｰLEDの色|%neo_color| \",\n  \"{id:category}Eureka_plotter_car\": \"プロットカー\",\n  \"{id:category}PlotLED_blocks\": \"プロットカーLED\",\n  \"{id:group}1 Control Pen\": \"1 ペンのじょうたい\",\n  \"{id:group}2 Basic control\": \"2 基本の動き\",\n  \"{id:group}3 Shape\": \"3 図形\",\n  \"{id:group}4 Default setting\": \"4 初期設定\",\n  \"{id:group}5 Fine control\": \"5 調整\",\n  \"{id:group}6 Ultrasonic_Distance sensor\": \"6 超音波きょりｾﾝｻｰ\",\n  \"{id:group}7 photoreflector\": \"7 反射型光ｾﾝｻｰ\",\n  \"{id:group}8 microbit Optical_sensor\": \"8 ﾏｲｸﾛﾋﾞｯﾄ上の光ｾﾝｻｰ\",\n  \"{id:group}PlotcarLED\": \"ﾌﾟﾛｯﾄｶｰLED\"\n}","main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"-%zi6?Z!`tRJKc-[n1,P\">strip</variable><variable id=\"id6=2t2`UF^rTbs%IFs-\">選択</variable></variables><block type=\"pxt-on-start\" id=\"UM-K818.bb?~0A]8}(`j\" x=\"17\" y=\"-1\"/><block type=\"device_forever\" id=\"bu#:S%Ps~2S}r0tq]stD\" x=\"196\" y=\"5\"/><block type=\"device_button_event\" id=\"cEGt4U()qlXrm/l6TB=V\" x=\"23\" y=\"124\"><field name=\"NAME\">Button.A</field></block></xml>","main.ts":"input.onButtonPressed(Button.A, function () {\r\n\t\r\n})\r\nbasic.forever(function () {\r\n\t\r\n})\r\n","plotcarv36.ts":"/* Plot_car Ver4.0 2022/7/29 \r\n   eureka.niigata.jp  */\r\n   let wait = 0;\r\n   let Tugi_R = 0;\r\n   let Tugi_L = 0;\r\n   let T1 = 0;\r\n   let PremotionR = 0;\r\n   let PremotionL = 0;\r\n   let con_kaiten = 1.61;\r\n   \r\n   \r\n   \r\n   let cond_Distance = 1;\r\n   let cond_degree = 1;\r\n   let microbit_wait = 750;\r\n   \r\n   /*   let  = [\r\n          [0, 0, 0, 0],\r\n          [0, 0, 0, 0],\r\n          [0, 0, 0, 0],\r\n          [0, 0, 0, 0],\r\n      ];\r\n      \r\n   */\r\n   let Stepping_non = [\r\n       [0, 0, 0, 0],\r\n       [0, 0, 0, 0],\r\n       [0, 0, 0, 0],\r\n       [0, 0, 0, 0],\r\n   ];\r\n   \r\n   let SteppingF_0 = [\r\n       [1, 1, 0, 0],\r\n       [0, 1, 1, 0],\r\n       [0, 0, 1, 1],\r\n       [1, 0, 0, 1],\r\n       [1, 1, 0, 0],\r\n       [0, 1, 1, 0],\r\n       [0, 0, 1, 1],\r\n   ];\r\n   let SteppingF_1 = [\r\n       [0, 1, 1, 0],\r\n       [0, 0, 1, 1],\r\n       [1, 0, 0, 1],\r\n       [1, 1, 0, 0],\r\n       [0, 1, 1, 0],\r\n       [0, 0, 1, 1],\r\n       [1, 0, 0, 1],\r\n   ];\r\n   let SteppingF_2 = [\r\n       [0, 0, 1, 1],\r\n       [1, 0, 0, 1],\r\n       [1, 1, 0, 0],\r\n       [0, 1, 1, 0],\r\n       [0, 0, 1, 1],\r\n       [1, 0, 0, 1],\r\n       [1, 1, 0, 0],\r\n   ];\r\n   let SteppingF_3 = [\r\n       [1, 0, 0, 1],\r\n       [1, 1, 0, 0],\r\n       [0, 1, 1, 0],\r\n       [0, 0, 1, 1],\r\n       [1, 0, 0, 1],\r\n       [1, 1, 0, 0],\r\n       [0, 1, 1, 0],\r\n   ];\r\n   \r\n   let SteppingB_0 = [\r\n       [1, 0, 0, 1],\r\n       [0, 0, 1, 1],\r\n       [0, 1, 1, 0],\r\n       [1, 1, 0, 0],\r\n       [1, 0, 0, 1],\r\n       [0, 0, 1, 1],\r\n       [0, 1, 1, 0],\r\n   ];\r\n   let SteppingB_1 = [\r\n   \r\n       [0, 0, 1, 1],\r\n       [0, 1, 1, 0],\r\n       [1, 1, 0, 0],\r\n       [1, 0, 0, 1],\r\n       [0, 0, 1, 1],\r\n       [0, 1, 1, 0],\r\n       [1, 1, 0, 0],\r\n   ];\r\n   \r\n   let SteppingB_2 = [\r\n       [0, 1, 1, 0],\r\n       [1, 1, 0, 0],\r\n       [1, 0, 0, 1],\r\n       [0, 0, 1, 1],\r\n       [0, 1, 1, 0],\r\n       [1, 1, 0, 0],\r\n       [1, 0, 0, 1],\r\n   ];\r\n   let SteppingB_3 = [\r\n   \r\n       [1, 1, 0, 0],\r\n       [1, 0, 0, 1],\r\n       [0, 0, 1, 1],\r\n       [0, 1, 1, 0],\r\n       [1, 1, 0, 0],\r\n       [1, 0, 0, 1],\r\n       [0, 0, 1, 1],\r\n   ];\r\n   \r\n   let Stepping_R = [\r\n       [0, 0, 0, 0],\r\n       [0, 0, 0, 0],\r\n       [0, 0, 0, 0],\r\n       [0, 0, 0, 0],\r\n   ];\r\n   \r\n   let Stepping_L = [\r\n       [0, 0, 0, 0],\r\n       [0, 0, 0, 0],\r\n       [0, 0, 0, 0],\r\n       [0, 0, 0, 0],\r\n   ];\r\n   \r\n   //LED不使用\r\n   led.enable(false)\r\n   \r\n   pins.digitalWritePin(DigitalPin.P3, 0)\r\n   pins.digitalWritePin(DigitalPin.P4, 0)\r\n   pins.digitalWritePin(DigitalPin.P6, 0)\r\n   pins.digitalWritePin(DigitalPin.P7, 0)\r\n   pins.digitalWritePin(DigitalPin.P13, 0)\r\n   pins.digitalWritePin(DigitalPin.P14, 0)\r\n   pins.digitalWritePin(DigitalPin.P15, 0)\r\n   pins.digitalWritePin(DigitalPin.P16, 0)\r\n   \r\n   let moter_number = 0;\r\n   let io_neo = neopixel.create(DigitalPin.P9, 4, NeoPixelMode.RGB);\r\n   io_neo.showRainbow(1, 360)\r\n   pins.servoWritePin(AnalogPin.P8, 90);\r\n   basic.pause(100);\r\n   \r\n   //バージョンの判定\r\n   let first = input.runningTimeMicros()\r\n   let sum = 0\r\n   for (let index = 0; index < 1000; index++) {\r\n       sum += 1\r\n   }\r\n   //basic.showNumber(input.runningTimeMicros() - first);\r\n   if ((input.runningTimeMicros() - first) < 2000) {\r\n       microbit_wait = 4500;\r\n       //    basic.showString(\"V2\");\r\n   \r\n   }\r\n   else {\r\n       microbit_wait = 900;\r\n       //    basic.showString(\"V1\");\r\n   }\r\n   \r\n   \r\n   //% color=\"#3943c6\" block=\"Plotcar Ver3.6\" weight=95 icon=\"\\uf1b9\"\r\n   namespace eureka_plotter_car {\r\n   \r\n       export enum pen_updown {\r\n           //% block=\"down\"\r\n           down,\r\n           //% block=\"up\"\r\n           up\r\n       }\r\n   \r\n       export enum plotter_houkou {\r\n           //% block=\"forward\"\r\n           forward,\r\n           //% block=\"backward\"\r\n           backward\r\n       }\r\n   \r\n       export enum plotter_RL {\r\n           //% block=\"right\"\r\n           right,\r\n           //% block=\"left\"\r\n           left\r\n       }\r\n   \r\n   \r\n       export enum microbit_LED {\r\n           //% block=\"disable\"\r\n           disable,\r\n           //% block=\"activate\"\r\n           activate\r\n       }\r\n   \r\n       export enum houkou {\r\n           //% block=\"right_angle\"\r\n           right_angle,\r\n           //% block=\"left_angle\"\r\n           left_angle,\r\n           //% block=\"diagonal_right\"\r\n           diagonal_right,\r\n           //% block=\"diagonal_left\"\r\n           diagonal_left\r\n       }\r\n   \r\n   \r\n       export enum kyori {\r\n           //% block=\"long\"\r\n           long,\r\n           //% block=\"short\",\r\n           short\r\n       }\r\n       export enum sence_select {\r\n           //% block=\"normal30\"\r\n           normal30,\r\n           //% block=\"High_sensitivity\"\r\n           High_sensitivity,\r\n           //% block=\"Low_sensitivity\",\r\n           Low_sensitivity\r\n       }\r\n       export enum microbit_version {\r\n           //% block=\"Version1\"\r\n           Version1,\r\n           //% block=\"Version2\"\r\n           Version2,\r\n           //% block=\"Test_A\"\r\n           Test_A,\r\n           //% block=\"Test_B\"\r\n           Test_B,\r\n           //% block=\"V1_Turbo\"\r\n           V1_Turbo,\r\n           //% block=\"V2_Turbo\"\r\n           V2_Turbo\r\n       }\r\n   \r\n       export enum onoff {\r\n           //% block=\"ON\"\r\n           ON,\r\n           //% block=\"OFF\"\r\n           OFF\r\n       }\r\n       export enum whiteblack {\r\n           //% block=\"black\"\r\n           black,\r\n           //% block=\"white\"\r\n           white\r\n       }\r\n   \r\n   \r\n   \r\n   \r\n   \r\n   \r\n   \r\n   \r\n       function moter(kyori: number, R_zengo: number, L_zengo: number) {\r\n           led.enable(false);\r\n           let i = 0;\r\n           /* 端数の計算計算  */\r\n   \r\n           let kyori_hasuu = kyori % 1;\r\n           serial.writeValue(\"kyori_hasuu\", kyori_hasuu);\r\n           let kyori_seisuu = Math.floor(kyori);\r\n           /*    serial.writeValue(\"kyori_seisuu\", kyori_seisuu);*/\r\n   \r\n   \r\n           /* forward回の動作との比較と処理  */\r\n           serial.writeValue(\"1Tugi_L\", Tugi_L);\r\n           if (PremotionR == R_zengo) {\r\n               Tugi_R = Tugi_R + 1;\r\n           }\r\n           if (PremotionR > R_zengo) {\r\n               Tugi_R = 3 - Tugi_R + 1;\r\n           }\r\n           if (PremotionR < R_zengo) {\r\n               Tugi_R = 3 - Tugi_R + 1;\r\n           }\r\n   \r\n           if (PremotionL == L_zengo) {\r\n               Tugi_L = Tugi_L + 1;\r\n           }\r\n           if (PremotionL > L_zengo) {\r\n               Tugi_L = 3 - Tugi_L + 1;\r\n           }\r\n           if (PremotionL < L_zengo) {\r\n               Tugi_L = 3 - Tugi_L + 1;\r\n           }\r\n   \r\n   \r\n           /*   次のstep*/\r\n           Tugi_L = (Tugi_L) % 4;\r\n           Tugi_R = (Tugi_R) % 4;\r\n   \r\n           /*右ステッピングの処理*/\r\n           switch (R_zengo) {\r\n               case 0:\r\n                   Stepping_R = Stepping_non;\r\n                   break;\r\n                   if (Tugi_R == 0) {\r\n                       Stepping_R = SteppingF_0\r\n                   }\r\n                   break;\r\n               case 1:\r\n   \r\n                   if (Tugi_R == 0) {\r\n                       Stepping_R = SteppingB_0\r\n                   }\r\n                   if (Tugi_R == 1) {\r\n                       Stepping_R = SteppingB_1\r\n                   }\r\n                   if (Tugi_R == 2) {\r\n                       Stepping_R = SteppingB_2\r\n                   }\r\n                   if (Tugi_R == 3) {\r\n                       Stepping_R = SteppingB_3\r\n                   }\r\n                   break;\r\n               case 2:\r\n                   if (Tugi_R == 0) {\r\n                       Stepping_R = SteppingF_0\r\n                   }\r\n                   if (Tugi_R == 1) {\r\n                       Stepping_R = SteppingF_1\r\n                   }\r\n                   if (Tugi_R == 2) {\r\n                       Stepping_R = SteppingF_2\r\n                   }\r\n                   if (Tugi_R == 3) {\r\n                       Stepping_R = SteppingF_3\r\n                   }\r\n                   break;\r\n   \r\n           }\r\n           Stepping_L = SteppingF_0\r\n           /*左ステッピングの処理*/\r\n           switch (L_zengo) {\r\n               case 0:\r\n                   Stepping_L = Stepping_non;\r\n                   break;\r\n               case 1:\r\n                   if (Tugi_L == 0) {\r\n                       Stepping_L = SteppingF_0\r\n                   }\r\n                   if (Tugi_L == 1) {\r\n                       Stepping_L = SteppingF_1\r\n                   }\r\n                   if (Tugi_L == 2) {\r\n                       Stepping_L = SteppingF_2\r\n                   }\r\n                   if (Tugi_L == 3) {\r\n                       Stepping_L = SteppingF_3\r\n                   }\r\n                   break;\r\n               case 2:\r\n                   if (Tugi_L == 0) {\r\n                       Stepping_L = SteppingB_0\r\n                   }\r\n                   if (Tugi_L == 1) {\r\n                       Stepping_L = SteppingB_1\r\n                   }\r\n                   if (Tugi_L == 2) {\r\n                       Stepping_L = SteppingB_2\r\n                   }\r\n                   if (Tugi_L == 3) {\r\n                       Stepping_L = SteppingB_3\r\n                   }\r\n                   break;\r\n           }\r\n   \r\n           /*  バックラッシュの処理　right_wheel*/\r\n           if (PremotionR != R_zengo) {\r\n               music.playTone(523, music.beat(BeatFraction.Sixteenth))\r\n               for (let index = 0; index < 3; index++) {\r\n                   let Data1 = 0;\r\n                   while (Data1 < 4) {\r\n                       pins.digitalWritePin(DigitalPin.P3, Stepping_R[Data1][0]);\r\n                       pins.digitalWritePin(DigitalPin.P4, Stepping_R[Data1][1]);\r\n                       pins.digitalWritePin(DigitalPin.P6, Stepping_R[Data1][2]);\r\n                       pins.digitalWritePin(DigitalPin.P7, Stepping_R[Data1][3]);\r\n                       Data1 = Data1 + 1;\r\n                       for (i = 0; i < microbit_wait; i++);\r\n                       {\r\n                       }\r\n                   }\r\n               }\r\n           }\r\n   \r\n   \r\n           /*  バックラッシュの処理　left_wheel*/\r\n           if (PremotionL != L_zengo) {\r\n               music.playTone(523, music.beat(BeatFraction.Sixteenth))\r\n               for (let index = 0; index < 3; index++) {\r\n                   let Data1 = 0;\r\n                   while (Data1 < 4) {\r\n                       pins.digitalWritePin(DigitalPin.P13, Stepping_L[Data1][0]);\r\n                       pins.digitalWritePin(DigitalPin.P14, Stepping_L[Data1][1]);\r\n                       pins.digitalWritePin(DigitalPin.P15, Stepping_L[Data1][2]);\r\n                       pins.digitalWritePin(DigitalPin.P16, Stepping_L[Data1][3]);\r\n                       Data1 = Data1 + 1;\r\n                       for (i = 0; i < microbit_wait; i++);\r\n                       {\r\n                       }\r\n                   }\r\n               }\r\n           }\r\n   \r\n   \r\n           /*  整数部の処理　 */\r\n           for (let index = 0; index < kyori_seisuu; index++) {\r\n               let Data1 = 0;\r\n               while (Data1 < 4) {\r\n   \r\n                   pins.digitalWritePin(DigitalPin.P3, Stepping_R[Data1][0]);\r\n                   pins.digitalWritePin(DigitalPin.P13, Stepping_L[Data1][0]);\r\n                   pins.digitalWritePin(DigitalPin.P4, Stepping_R[Data1][1]);\r\n                   pins.digitalWritePin(DigitalPin.P14, Stepping_L[Data1][1]);\r\n                   pins.digitalWritePin(DigitalPin.P6, Stepping_R[Data1][2]);\r\n                   pins.digitalWritePin(DigitalPin.P15, Stepping_L[Data1][2]);\r\n                   pins.digitalWritePin(DigitalPin.P7, Stepping_R[Data1][3]);\r\n                   pins.digitalWritePin(DigitalPin.P16, Stepping_L[Data1][3]);\r\n                   Data1 = Data1 + 1;\r\n                   for (i = 0; i < microbit_wait; i++);\r\n                   {\r\n                   }\r\n               }\r\n           }\r\n   \r\n           /* 端数分の進み方と処理  */\r\n           let Step_number = Math.floor(kyori_hasuu * 10 / 2.5);\r\n           let Data1 = 0;\r\n           while (Data1 < Step_number) {\r\n               serial.writeValue(\"Data1\", Data1);\r\n               pins.digitalWritePin(DigitalPin.P3, Stepping_R[Data1][0]);\r\n               pins.digitalWritePin(DigitalPin.P13, Stepping_L[Data1][0]);\r\n               pins.digitalWritePin(DigitalPin.P4, Stepping_R[Data1][1]);\r\n               pins.digitalWritePin(DigitalPin.P14, Stepping_L[Data1][1]);\r\n               pins.digitalWritePin(DigitalPin.P6, Stepping_R[Data1][2]);\r\n               pins.digitalWritePin(DigitalPin.P15, Stepping_L[Data1][2]);\r\n               pins.digitalWritePin(DigitalPin.P7, Stepping_R[Data1][3]);\r\n               pins.digitalWritePin(DigitalPin.P16, Stepping_L[Data1][3]);\r\n               Data1 = Data1 + 1;\r\n               for (i = 0; i < microbit_wait; i++);\r\n               {\r\n               }\r\n           }\r\n   \r\n           Tugi_L = (Tugi_L + Data1 - 1) % 4;\r\n           Tugi_R = (Tugi_R + Data1 - 1) % 4;\r\n   \r\n           PremotionR = R_zengo;\r\n           PremotionL = L_zengo;\r\n   \r\n       }\r\n   \r\n   \r\n       //% color=\"#009CA0\" weight=96 blockId=eureka_relay block=\"pen |%mode| \" group=\"1 Control Pen\"\r\n       export function plottercar_pen(mode: pen_updown) {\r\n           if (mode == pen_updown.up) {\r\n               pins.servoWritePin(AnalogPin.P8, 90);\r\n               basic.pause(1000);\r\n           }\r\n           if (mode == pen_updown.down) {\r\n               pins.servoWritePin(AnalogPin.P8, 0);\r\n               basic.pause(100);\r\n           }\r\n   \r\n       }\r\n   \r\n       //% color=\"#ff1493\" weight=90 blockId=eureka_relay2 block=\"New_pen |%mode| \" group=\"1 Control Pen\"\r\n       export function plottercar_pen2(mode: pen_updown) {\r\n           if (mode == pen_updown.up) {\r\n               pins.servoWritePin(AnalogPin.P8, 90);\r\n               basic.pause(1000);\r\n           }\r\n   \r\n           if (mode == pen_updown.down) {\r\n               pins.servoWritePin(AnalogPin.P8, 45);\r\n               basic.pause(100);\r\n           }\r\n       }\r\n   \r\n       //% color=\"#3943c6\" weight=80 blockId=plottercar_zengo\r\n       //% block=\"Move |%zengo| |%F_cm| cm\" group=\"2 Basic control\"\r\n       export function plottercar_zengo(zengo: plotter_houkou, F_cm: number): void {\r\n           switch (zengo) {\r\n               case plotter_houkou.forward:\r\n                   moter_number = F_cm / (18.9 * cond_Distance) * 512;\r\n                   moter(moter_number, 1, 1);\r\n                   break;\r\n   \r\n               case plotter_houkou.backward:\r\n                   moter_number = F_cm / (18.9 * cond_Distance) * 512;\r\n                   moter(moter_number, 2, 2);\r\n                   break;\r\n           }\r\n       }\r\n   \r\n       //% color=\"#3943c6\" weight=76 blockId=plottercar_RL_cycle\r\n       //% block=\"Rotate |%L_degree|degrees to |%RorL|\" group=\"2 Basic control\"\r\n       export function plottercar_RL_cycle(RL_degree: number, RorL: plotter_RL): void {\r\n           switch (RorL) {\r\n               case plotter_RL.left:\r\n                   moter_number = RL_degree / 360 * 512 * con_kaiten * cond_degree;\r\n                   moter(moter_number, 1, 2);\r\n                   break;\r\n               case plotter_RL.right:\r\n                   moter_number = RL_degree / 360 * 512 * con_kaiten * cond_degree;\r\n                   moter(moter_number, 2, 1);\r\n                   break;\r\n           }\r\n       }\r\n   \r\n   \r\n       //% color=\"#ff4940\" weight=71 blockId=plottercar_rest\r\n       //% block=\"power off\" group=\"2 Basic control\"\r\n       export function plottercar_frest(): void {\r\n           moter_number = 1;\r\n           moter(moter_number, 0, 1);\r\n       }\r\n   \r\n   \r\n   \r\n   \r\n       //% color=\"#3943c6\" weight=72 blockId=plottercar_houkou\r\n       //% block=\"change direction to|%muki|\" group=\"2 Basic control\"\r\n       export function plottercar_houkou(muki: houkou): void {\r\n           switch (muki) {\r\n               case houkou.right_angle:\r\n                   return eureka_plotter_car.plottercar_RL_cycle(plotter_RL.right, 90);\r\n               case houkou.left_angle:\r\n                   return eureka_plotter_car.plottercar_RL_cycle(plotter_RL.left, 90);\r\n               case houkou.diagonal_right:\r\n                   return eureka_plotter_car.plottercar_RL_cycle(plotter_RL.right, 45);\r\n               case houkou.diagonal_left:\r\n                   return eureka_plotter_car.plottercar_RL_cycle(plotter_RL.left, 45);\r\n           }\r\n       }\r\n   \r\n   \r\n   \r\n       //% color=\"#009A00\" weight=40 blockId=polygon\r\n       //% block=\"Run |%RorL|,|%digree_step| sides polygon,|%Edge_Num|cm length\" group=\"3 Shape\"\r\n       export function polygon(RorL: plotter_RL, digree_step: number, Edge_Num: number): void {\r\n           switch (RorL) {\r\n               case plotter_RL.right:\r\n                   for (let index = 0; index < digree_step; index++) {\r\n                       eureka_plotter_car.plottercar_zengo(plotter_houkou.forward, Edge_Num)\r\n                       eureka_plotter_car.plottercar_RL_cycle(360 / digree_step, plotter_RL.right)\r\n                   }\r\n                   break;\r\n               case plotter_RL.left:\r\n                   for (let index = 0; index < digree_step; index++) {\r\n                       eureka_plotter_car.plottercar_zengo(plotter_houkou.forward, Edge_Num)\r\n                       eureka_plotter_car.plottercar_RL_cycle(360 / digree_step, plotter_RL.left)\r\n                   }\r\n                   break;\r\n           }\r\n       }\r\n   \r\n   \r\n       //% color=\"#009A00\" weight=39 blockId=cycle\r\n       //% block=\"circlate |%RorL|,dia.|%D_Num|cm\" group=\"3 Shape\"\r\n       export function cycle(RorL: plotter_RL, D_Num: number): void {\r\n           let cir = D_Num * 3.14\r\n           let forward_D = cir / 30\r\n           switch (RorL) {\r\n               case plotter_RL.right:\r\n                   for (let index = 0; index < 30; index++) {\r\n                       eureka_plotter_car.plottercar_zengo(plotter_houkou.forward, forward_D)\r\n                       eureka_plotter_car.plottercar_RL_cycle(360 / 30, plotter_RL.right)\r\n                   }\r\n                   break;\r\n               case plotter_RL.left:\r\n                   for (let index = 0; index < 30; index++) {\r\n                       eureka_plotter_car.plottercar_zengo(plotter_houkou.forward, forward_D)\r\n                       eureka_plotter_car.plottercar_RL_cycle(360 / 30, plotter_RL.left)\r\n                   }\r\n   \r\n           }\r\n       }\r\n   \r\n   \r\n   \r\n       //% color=\"#ff3d03\" weight=34 blockId=Microbit_Version_info block=\"micro:bit_Version |%Version_info|\" group=\"4 Default setting\"\r\n       export function microbit_version_info(Version_info: microbit_version) {\r\n           switch (Version_info) {\r\n               case microbit_version.Version1:\r\n                   microbit_wait = 900;\r\n                   break;\r\n               case microbit_version.Version2:\r\n                   microbit_wait = 5000;\r\n                   break;\r\n               case microbit_version.Test_A:\r\n                   microbit_wait = 10000;\r\n                   break;\r\n               case microbit_version.Test_B:\r\n                   microbit_wait = 90000;\r\n                   break;\r\n               case microbit_version.V1_Turbo:\r\n                   microbit_wait = 600;\r\n                   break;\r\n               case microbit_version.V2_Turbo:\r\n                   microbit_wait = 2000;\r\n                   break;\r\n   \r\n   \r\n           }\r\n       }\r\n   \r\n   \r\n   \r\n       //% color=\"#ff3d03\" weight=35 blockId=auto_led_off block=\"micro:bit LED |%Matrix_LED|\" group=\"4 Default setting\"\r\n       export function auto_led_off(Matrix_LED: microbit_LED) {\r\n           switch (Matrix_LED) {\r\n               case microbit_LED.disable:\r\n                   led.enable(false);\r\n                   break;\r\n               case microbit_LED.activate:\r\n                   led.enable(true);\r\n           }\r\n       }\r\n       //% color=\"#ffa800\" weight=20 blockId=plotter_Distance\r\n       //% block=\"Travel distance adjustment(1/1000) shorter|%Dis|longer\" group=\"5 Fine control\"\r\n       //% Dis.min=-30 Dis.max=30\r\n       export function plotter_Distance(Dis: number): void {\r\n           cond_Distance = (1 + Dis / 1000);\r\n       }\r\n   \r\n       //% color=\"#ffa800\" weight=18 blockId=plotter_degree\r\n       //% block=\"Rotation angle adjustment(1/1000) Less|%Deg|more\" group=\"5 Fine control\"\r\n       //% Deg.min=-30 Deg.max=30\r\n       export function plotter_degree(Deg: number): void {\r\n           cond_degree = (1 + Deg / 1000);\r\n       }\r\n   \r\n       //% color=\"#3943c6\" weight=55 blockId=plottercar_R_step\r\n       //% block=\"Right_wheel move |%houkou| |%R_step|steps\" group=\"5 Fine control\"\r\n   \r\n       export function plottercar_R_step(houkou: plotter_houkou, R_step: number): void {\r\n           moter_number = R_step;\r\n           switch (houkou) {\r\n               case plotter_houkou.forward:\r\n                   moter(R_step / 4, 1, 0);\r\n                   return;\r\n               case plotter_houkou.backward:\r\n                   moter(R_step / 4, 2, 0);\r\n                   return;\r\n           }\r\n       }\r\n       //% color=\"#3943c6\" weight=58 blockId=plottercar_L_step\r\n       //% block=\"Left wheel move |%houkou| |%L_step|steps\" group=\"5 Fine control\"\r\n       export function plottercar_L_step(houkou: plotter_houkou, L_step: number): void {\r\n           moter_number = L_step;\r\n           switch (houkou) {\r\n               case plotter_houkou.forward:\r\n                   moter(L_step / 4, 0, 1);\r\n                   return;\r\n               case plotter_houkou.backward:\r\n                   moter(L_step / 4, 0, 2);\r\n                   return;\r\n           }\r\n       }\r\n   \r\n   \r\n   \r\n   \r\n   \r\n       //% color=\"#009A00\" weight=22 blockId=sonar_ping_2 block=\"Distance sensor\" group=\"6 Ultrasonic_Distance sensor\"\r\n       //% advanced=true\r\n       export function sonar_ping_2(): number {\r\n           let d1 = 0;\r\n           let d2 = 0;\r\n   \r\n           for (let i = 0; i < 5; i++) {\r\n               // send\r\n               basic.pause(5);\r\n               pins.setPull(DigitalPin.P2, PinPullMode.PullNone);\r\n               pins.digitalWritePin(DigitalPin.P2, 0);\r\n               control.waitMicros(2);\r\n               pins.digitalWritePin(DigitalPin.P2, 1);\r\n               control.waitMicros(10);\r\n               pins.digitalWritePin(DigitalPin.P2, 0);\r\n               // read\r\n               d1 = pins.pulseIn(DigitalPin.P0, PulseValue.High, 500 * 58);\r\n               d2 = d2 + d1;\r\n           }\r\n           return Math.round(Math.idiv(d2 / 5, 58) * 1.5);\r\n       }\r\n   \r\n       //% color=\"#009A00\" weight=30 block=\"(minimam 5cm) dstance |%limit| cm  |%nagasa| \" group=\"6 Ultrasonic_Distance sensor\"\r\n       //% limit.min=5 limit.max=30\r\n       //% advanced=true\r\n       export function sonar_ping_3(limit: number, nagasa: kyori): boolean {\r\n           let d1 = 0;\r\n           let d2 = 0;\r\n           if (limit < 8) {\r\n               limit = 8\r\n           }\r\n           for (let i = 0; i < 5; i++) {\r\n               // send\r\n               basic.pause(5);\r\n               pins.setPull(DigitalPin.P2, PinPullMode.PullNone);\r\n               pins.digitalWritePin(DigitalPin.P2, 0);\r\n               control.waitMicros(2);\r\n               pins.digitalWritePin(DigitalPin.P2, 1);\r\n               control.waitMicros(10);\r\n               pins.digitalWritePin(DigitalPin.P2, 0);\r\n               // read\r\n               d1 = pins.pulseIn(DigitalPin.P0, PulseValue.High, 500 * 58);\r\n               d2 = d1 + d2;\r\n           }\r\n           switch (nagasa) {\r\n               case kyori.short:\r\n                   if (Math.idiv(d2 / 5, 58) * 1.5 < limit) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n               case kyori.long:\r\n                   if (Math.idiv(d2 / 5, 58) * 1.5 < limit) {\r\n                       return false;\r\n                   } else {\r\n                       return true;\r\n                   }\r\n                   break;\r\n           }\r\n       }\r\n   \r\n   \r\n       //% color=\"#f071bd\" weight=30 blockId=auto_photo_R block=\"right_photoreflector\" group=\"7 photoreflector\"\r\n       //% advanced=true\r\n       export function phto_R() {\r\n           return Math.round((pins.analogReadPin(AnalogPin.P10) / 1023) * 100);\r\n       }\r\n   \r\n       //% color=\"#f071bd\" weight=28 blockId=auto_photo_L block=\"left_photoreflector\" group=\"7 photoreflector\"\r\n       //% advanced=true\r\n       export function phto_L() {\r\n           return Math.round((pins.analogReadPin(AnalogPin.P1) / 1023) * 100);\r\n       }\r\n   \r\n       //% color=\"#d4b41f\"  weight=26 block=\"right_photoreflector |%limit_R| small\" group=\"7 photoreflector\"\r\n       //% limit_R.min=0 limit_R.max=100\r\n       //% advanced=true\r\n       export function photo_R(limit_R: number): boolean {\r\n           if (eureka_plotter_car.phto_R() <= limit_R) {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           if (eureka_plotter_car.phto_L() <= limit_R) {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           io_neo.show()\r\n           if ((pins.analogReadPin(AnalogPin.P10) / 1023) * 100 < limit_R) {\r\n               return true;\r\n           } else {\r\n               return false;\r\n           }\r\n       }\r\n   \r\n       //% color=\"#d4b41f\"  weight=27 block=\"left_photoreflector |%limit_L| small\" group=\"7 photoreflector\"\r\n       //% limit_L.min=0 limit_L.max=100\r\n       //% advanced=true\r\n       export function photo_L(limit_L: number): boolean {\r\n           if (eureka_plotter_car.phto_R() <= limit_L) {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           if (eureka_plotter_car.phto_L() <= limit_L) {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           io_neo.show()\r\n           if ((pins.analogReadPin(AnalogPin.P1) / 1023) * 100 < limit_L) {\r\n               return true;\r\n           } else {\r\n               return false;\r\n           }\r\n       }\r\n   \r\n       //% color=\"#6041f1\"  weight=33 block=\"only right |%wb| stepping on  |%sikii| \" group=\"7 photoreflector\"\r\n       //% sence.min=10 sence.max=40\r\n       //% advanced=true\r\n       export function photo_R_out(wb: whiteblack, sikii: sence_select): boolean {\r\n           if (sikii == sence_select.Low_sensitivity) {\r\n               sikii = 60;\r\n           }\r\n           if (sikii == sence_select.normal30) {\r\n               sikii = 50;\r\n           }\r\n           if (sikii == sence_select.High_sensitivity) {\r\n               sikii = 40;\r\n           }\r\n           if (eureka_plotter_car.phto_R() <= sikii) {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           if (eureka_plotter_car.phto_L() <= sikii) {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           io_neo.show()\r\n           switch (wb) {\r\n               case whiteblack.black:\r\n                   if ((pins.analogReadPin(AnalogPin.P1) / 1023) * 100 > sikii && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 < sikii) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n               case whiteblack.white:\r\n                   if ((pins.analogReadPin(AnalogPin.P1) / 1023) * 100 < sikii && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 > sikii) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n           }\r\n       }\r\n   \r\n       //% color=\"#6041f1\"  weight=34 block=\"onle left |%wb| stepping on threshold |%sikii| \" group=\"7 photoreflector\" \r\n       //% advanced=true\r\n       export function photo_L_out(wb: whiteblack, sikii: sence_select): boolean {\r\n           if (sikii == sence_select.Low_sensitivity) {\r\n               sikii = 60;\r\n           }\r\n           if (sikii == sence_select.normal30) {\r\n               sikii = 50;\r\n           }\r\n           if (sikii == sence_select.High_sensitivity) {\r\n               sikii = 40;\r\n           }\r\n           if (eureka_plotter_car.phto_R() <= sikii) {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           if (eureka_plotter_car.phto_L() <= sikii) {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           io_neo.show()\r\n           switch (wb) {\r\n               case whiteblack.black:\r\n                   if (\r\n   \r\n                       (pins.analogReadPin(AnalogPin.P1) / 1023) * 100 < sikii && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 > sikii) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n               case whiteblack.white:\r\n                   if ((pins.analogReadPin(AnalogPin.P1) / 1023) * 100 > sikii && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 < sikii) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n           }\r\n       }\r\n       //% color=\"#6041f1\"  weight=35 block=\"Both |%wb| stepping on threshold threshold |%sikii| \" group=\"7 photoreflector\"\r\n       //% advanced=true\r\n       export function photo_LR_out(wb: whiteblack, sikii: sence_select): boolean {\r\n           if (sikii == sence_select.Low_sensitivity) {\r\n               sikii = 60;\r\n           }\r\n           if (sikii == sence_select.normal30) {\r\n               sikii = 50;\r\n           }\r\n           if (sikii == sence_select.High_sensitivity) {\r\n               sikii = 40;\r\n           }\r\n           if (eureka_plotter_car.phto_R() <= sikii) {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           if (eureka_plotter_car.phto_L() <= sikii) {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           io_neo.show()\r\n           switch (wb) {\r\n               case whiteblack.black:\r\n                   if (\r\n                       (pins.analogReadPin(AnalogPin.P1) / 1023) * 100 <= sikii && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 <= sikii) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n   \r\n               case whiteblack.white:\r\n   \r\n                   if (\r\n                       (pins.analogReadPin(AnalogPin.P1) / 1023) * 100 >= sikii && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 >= sikii) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n           }\r\n   \r\n       }\r\n   \r\n       //% color=\"#009A00\"  weight=19 blockId=microbit2_decideLight block=\"m:bitOptical sensor value |%limit| Darker\" group=\"8 microbit Optical_sensor\"\r\n       //% limit.min=0 limit.max=100\r\n       //% advanced=true\r\n       export function microbit2_decideLight(limit: number): boolean {\r\n           if (input.lightLevel() / 254 * 100 < limit) {\r\n               return true;\r\n           } else {\r\n               return false;\r\n           }\r\n       }\r\n   \r\n   \r\n   \r\n       //% color=\"#009A00\"  weight=17 blockId=microbit2_denkitemp block=\"m:bitOptical sensor value\" group=\"8 microbit Optical_sensor\"\r\n       //% advanced=true\r\n       export function microbit2_denkitemp(): number {\r\n   \r\n           return Math.round(input.lightLevel() / 254 * 100);\r\n   \r\n       }\r\n   \r\n       /*\r\n           //% color=\"#228b22\"  weight=16 blockId=microbit2_denkiLED block=\"m:bit Optical sensor value\" group=\"8 microbit Optical_sensor\"\r\n           //% advanced=true\r\n           export function microbit2_denkiLED() {\r\n               basic.showNumber(Math.round(input.lightLevel() / 254 * 100));\r\n           }\r\n       */\r\n   \r\n   \r\n   \r\n   \r\n   }\r\n   \r\n   //% color=\"#ff4500\" weight=94 block=\"Plotcar_LED\"\r\n   \r\n   namespace plotLED_blocks {\r\n   \r\n       export enum neoLED_color {\r\n           //% block=\"white\"\r\n           white,\r\n           //% block=\"red\"\r\n           red,\r\n           //% block=\"yellow\"\r\n           yellow,\r\n           //% block=\"green\"\r\n           green,\r\n           //% block=\"blue\"\r\n           blue,\r\n           //% block=\"orange\"\r\n           orange,\r\n           //% block=\"indigo\"\r\n           indigo,\r\n           //% block=\"violet\"\r\n           violet,\r\n           //% block=\"purple\"\r\n           purple,\r\n           //% block=\"black\"\r\n           black\r\n       }\r\n   \r\n   \r\n   \r\n   \r\n       //% color=\"#20b2aa\" weight=82 blockId=neopixel_select block=\"FullcolorLED color|%neo_color| \" group=\"PlotcarLED\"\r\n       export function neopixel_select_block(neo_color: neoLED_color) {\r\n   \r\n           switch (neo_color) {\r\n               case neoLED_color.red:\r\n                   io_neo.showColor(neopixel.colors(NeoPixelColors.Red))\r\n                   break;\r\n               case neoLED_color.orange:\r\n                   io_neo.showColor(neopixel.colors(NeoPixelColors.Orange))\r\n                   break;\r\n               case neoLED_color.yellow:\r\n                   io_neo.showColor(neopixel.colors(NeoPixelColors.Yellow))\r\n                   break;\r\n               case neoLED_color.green:\r\n   \r\n                   io_neo.showColor(neopixel.colors(NeoPixelColors.Green))\r\n                   break;\r\n               case neoLED_color.blue:\r\n                   io_neo.showColor(neopixel.colors(NeoPixelColors.Blue))\r\n                   break;\r\n               case neoLED_color.indigo:\r\n                   io_neo.showColor(neopixel.colors(NeoPixelColors.Indigo))\r\n                   break;\r\n               case neoLED_color.violet:\r\n                   io_neo.showColor(neopixel.colors(NeoPixelColors.Violet))\r\n                   break;\r\n               case neoLED_color.purple:\r\n                   io_neo.showColor(neopixel.colors(NeoPixelColors.Purple))\r\n                   break;\r\n               case neoLED_color.white:\r\n                   io_neo.showColor(neopixel.colors(NeoPixelColors.White))\r\n                   break;\r\n               case neoLED_color.black:\r\n                   io_neo.showColor(neopixel.colors(NeoPixelColors.Black))\r\n                   break;\r\n           }\r\n       }\r\n   \r\n       //% color=\"#9400d3\" weight=81 blockId=neopixel_reinbow block=\"reinbow\" group=\"PlotcarLED\"\r\n       export function neopixel_rainbow() {\r\n           io_neo.showRainbow(1, 180)\r\n       }\r\n   \r\n       //% color=\"#cd853f\" weight=80 blockId=neopixel_erace block=\"FullcolorLED All_Erease\" group=\"PlotcarLED\"\r\n       export function neopixel_erace_block() {\r\n           for (let n = 0; n < 4; n++) {\r\n               io_neo.showColor(neopixel.colors(NeoPixelColors.Black))\r\n           }\r\n       }\r\n   \r\n       //% color=\"#1E90FF\" weight=83 block=\"wait_time(sec)|%second|\" group=\"PlotcarLED\"\r\n       //% second.min=0 second.max=10\r\n       export function driveForwards(second: number): void {\r\n           basic.pause(second * 1000);\r\n       }\r\n   \r\n   \r\n   \r\n   \r\n   }\r\n   \r\n   \r\n   \r\n   \r\n   ","pxt.json":"{\n    \"name\": \"plotcarv36\",\n    \"version\": \"0.0.0\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"neopixel\": \"github:Microsoft/pxt-neopixel#v0.7.3\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.blocks\",\n        \"main.ts\",\n        \"plotcarv36.ts\",\n        \"_locales/ja/plotcarv36-strings.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"4.0.18\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// テストはここに来ます。このパッケージが拡張機能として使用されるときにはコンパイルされません。\r\n"}